% !TEX root = ../thesis.tex

\begin{summary}
本文对内存完整性保护方案做了系统的分析，就内存完整性保护的大小，树中节点数据结构，危险模型与安全性分析做了仔细地探讨。通过对已有的内存完整性保护的研究发现，虽然已有的工作能够理论上实现
对GB级别的内存数据做完整性检查，但是任然不适合云场景中的TB级别的内存，以及安全内存的可扩展性。在本文中，我们提出了一种新颖的完整性保护数据结构：哈希森林以及可挂载完整性保护树。其中挂载的单位是子树，在MMT中子树还会处于三个状态：活跃，不活跃与未分配
并且针对子树的概念提出了两个新的动态操作：挂载（Mount）与卸载（Unmount）。本文通过这两个新增的完整性保护树的动态原语，实现了可扩展的内存完整性保护，动态的安全内存分配以及针对离散内存的保护。同时结合了内存访问的规律，
提出了三级counter的树节点架构，针对冷热counter做了进一步的优化，从而实现了在不影响安全性的前提下，增加了额树节点的扇出，扩大了内存保护的范围。

在论文中，实现了基于MMT完整性保护树，以及哈希森立的内存保护原型。通过在内存控制器中增加三个部件：Secure Bitmap；Mount Table；Root-of-root来实现子树的挂载，内存的完整性检查等操作。同时对内存中的布局就做进一步的细化，将内存区域分成了：非安全内存，
安全内存，子树区域与MMT元数据区域，为了保护MMT元数据区域内的数据不被攻击者篡改，我们才用了RISCV架构的M mode中monitor对该区域进行管理，同时采用pmp寄存器对MMT元素据区域进行隔离，保证特权软件无法篡改其中的子树的根节点。

在论文中，对针对内存的攻击进行了详细的分析与归类，并且通过密码学的方式证明了对内存完整性保护的可行性，同时也分析了不同数据结构可能带来的安全隐患。论文中详细分析MMT与VAULT, BMT等相关工作的安全性，虽然MMT采用了更加激进的counter组织方式，但是得益于对内存
访问pattern的观察，MMT会比VAULT有更强的安全性（更低的概率实现重放攻击）。之后的测试也表明，MMT所采用的树的数据结构并不会带来更多的运行时开销。

在实现中，对于树的配置：MMT子树的层数为3，保护的内存为4M，根树的层数时3，保护的内存为2M；SoC上的开销：Secure Bitmap大小为16K，Mount Table大小为512B；内存开销：MMT元数据区域大小约为2M。在极少的完整性保护树的层数下（<SGX的6层），极少了SoC空间开销的情况下（16Kb空间），我们实现了
对512G的内存数据的完整性保护，同时可有SoC保护的内存为128M。针对不同的情况，可以增加树的层数，以及Mount Table的容量，实现更多内存的完整性保护。

论文基于gem5模拟器实现了VAULT,SGX,MMT等多种内存完整性保护方案。首先我们测试了传统的交换页的机制对性能的影响，测试结果表明，交换页对占总运行时间的百分之40以上；其次我们测试在极限场景下，传统完整性保护方案的开销（7\sim8倍的开销）；最后我们基于SPECCPU对MMT和其他完整性保护方案进行了对比，
MMT均取得了最好的性能且Mount操作带来的额外开销小于1\%，保证了内存完整性保护的可扩展性。
\end{summary}
