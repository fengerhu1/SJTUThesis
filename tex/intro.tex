% !TEX root = ../thesis.tex

\chapter{概述}

\section{研究背景}
在数字化的当下，计算机安全越来越受到厂商与消费者们的关注，日益复杂的软件程序和各异的硬件平台暴露出了更多的安全隐患，其中与内存相关的攻击占了绝大多数。
基于内存的攻击可以分为两类：一类是软件攻击；另一类是硬件攻击。近年来研究者们通过新的硬件特性与软件架构，提出了诸多解决方案，其中内存完整性保护是不可或缺
的一点。内存的完整性保护机制保证了内存不会受到诸如修改、拼接、重放等物理攻击，提供了很强的安全保障。传统的完整性保护使用的是merkle tree，通过树状
结构，父节点中保存子节点的hash值，最后所有的数据将受到root hash的保护。 merkle hash发明以来受到广泛的应用，在文件系统、网络传输中起到了至关重要的作用
近几年，BMT，SIT等新的数据结构相继提出，尝试解决merkle tree存在的缺陷。

2016年，英特尔提出了Software Guard Extension（SGX），是第一个商用的可信执行环境并且提供了内存隔离，内存加密与内存完整性保护等强内存保护机制。SGX一经推出
就受到了学术界和工业界广泛的使用。虽然SGX提供了很强的安全保障，但是支持的内存只有128/256M，无法满足云场景下的需求，而限制SGX所保护内存大小的一个重要因素就是
内存完整性保护机制。在SGX中内存完整性保护的数据结构为Sgx Integrity Tree（SIT）。随着保护的内存增加，SIT的深度也随之增加，随之将带来严重的运行开销。SGX通过
限制SIT的深度（即限制了所保护内存的大小），来确保运行时的开销在一个可接受的范围内。 

在云计算普及的当下，计算机对内存的需求也越来越大，传统的merkle tree或者其变种无法支持在云场景下的TB级别的内存保护，2018年学术界提出了vault，用于扩展SIT所
保护的内存空间。虽然vault将受保护的内存扩大到了GB的量级，但是仍然无法满足云场景下的需求。另外所有的内存完整性保护方案都不支持动态的内存完整性保护，需要预留
15-25\%总内存用于储存完整性保护树的数据结构，这样的数据结构在云场景中与可扩展与弹性的内存分配机制相违背。为了解决内存完整性保护大小以及可扩展性问题，使内存
完整性保护方案能够适用于云端，为云端计算提供更强的内存保护机制，本文提出了一种新型的内存完整性保护数据结构，尝试解决这两个内存完整性保护工作中的痛点。通过将
静态完整性保护树演变为动态可挂载的完整性保护树，给予了内存完整性保护更多的弹性与可扩展性。

\section{研究现状}
本节将围绕内存完整性保护数据结构以及应用场景做进一步介绍

\subsection{内存完整性数据结构}
Merkle hash tree是使用最广泛的完整性保护的数据结构，之后的很多工作都是基于此做进一步的优化。完整性保护的核心想法是用较小的hash保护大量的数据内容不被修改，显然
仅通过一次hash操作来实现数据的完整性保护是不安全，因为只有一个hash值将极大的增加hash碰撞的概率，同时需要扫描完所有的数据之后，才能够计算出hash。在Merkle hash tree中采用了多个hash值的方式保护数据的完整性，
同时为了减少可信的hash数量，作者采用了树状的结构来管理所有的hash值。首先先将数据进行分块，每个数据块大小相同。其次对每个数据进行hash计算，得到对应的hash值。
然后将连续地N个hash值作为新的数据块，在此基础上再进行一次hash计算，得到新的hash值。以此迭代，直到得到唯一地hash值为止。需要对数据进行完整性检查的用户只需要持有根
节点中的hash值，然后通过hash tree的算法方式，通过数据重新计算出根节点中的hash，并且将保存的hash值与计算出的hash值进行比较，如果两者一直就说明数据的完整性得到保证。

Merkle tree的提出，使得完整性保护得计算不需要遍历所有得数据，极大得提高了完整性保护效率。同时只需要保存根节点得hash值就能保护所有得数据得完整性，减少了保存可信hash值
空间开销。得益于Merkle tree得精妙得设计，Merkle tree再数据完整性保护领域中得到了广泛得使用，之后所有的数据完整性结构也都是Merkle tree得变体，虽然Merkle tree设计非常
成功，但是也存在诸多缺陷，在数据越来越多的当下，Merkle tree深度逐渐增加，运行时的开销也逐渐增加；从而进一步演化出了基于计数的完整性保护方案，其中代表就是Bonsai Merkle Trees。
通过引入计数，增加了树的扇出，从而再相同的层数下，保护的内存更多。同时，基于计数的完整性保护方案也能够很好的和内存加密结合再一起，提供完整性和机密的双重保护。

\subsection{可信执行环境-Enclave}
enclave是计算机中中一块特殊的执行环境，在enclave中运行的代码无法被OS和hypervisor访问与管理，同时对于内存中的数据都是加密的形式保存，并且能够提供完整性的保护。基于enclave提供的
内存隔离，内存完整性保护，内存加密，能够使运行在enclave中程序免受软件（例如恶意的OS以及hyperbisor）与硬件的攻击（冷冻内存）。2016年，Intel 公司发布了第一代sgx， sgx是第一个商用的
enclave架构，通过微码实现在Intel的6代即以上的CPU中，在提供极高的安全保障（内存隔离，内存完整性保护，内存加密）。同时sgx的可信基被限制在cpu的内部，任何外部硬件，总线，以及任何特权软件
都在可信基之外。正是因为sgx提供了如此强的安全机制，在云场景中得到了广泛的使用，尤其是正对云上的可信计算，加解密等与安全密切相关的应用。在intel之后，amd、arm、riscv等不同计算机指令集
与制造上分别提出了各自的enclave架构。但是并没有提供和sgx一致的安全等级，指实现了内存隔离或加密，没有提供内存完整性保护。而其中最主要的因素就是已有的内存完整性保护机制无法很好的保护较大的
内存。

\subsection{非易失内存-NVM}
非易失性内存是新的存储介质，它同时兼备内存和硬盘的特性。非易失性内存像内存一样，可以直接插在DIMM上，并且CPU可以根据byte进行寻址；同时非易失内存于普通内存最大的区别在于，断电之后数据不会丢失，
同时相较于普通的内存，非易失内存可以做到更大的容量，一根非易失内存就可以达轻松达到512GB，1TB的大小。在性能方面，非易失内存在读写方面和内存相近，但是存在明显的读写不平衡，跟固态硬盘相似
非易失内存也存在写穿的问题。得益于非易失性内存的诸多好处，学术界和工业界对非易事性内存做了广泛的研究，其中如何保证非易失性内存中数据的安全变得格外的重要。与普通的内存不同，非易失性内存中的
数据在断电之后并不会丢失，所以攻击者可以非常方便的将非易失内存从DIMM上拔下来，然后插到另外的主机上读取其中的数据。非易失内存的出现，使得针对内存的攻击更加可行，所以对内存的完整性保护也更为
主要。同时由于非易失性内存的大小往往在TB左右，导致了已有的完整性保护方案并不能直接迁移到非易失性内存中，同时写穿等问题也会带来额外的挑战。

\section{主要研究内容}
本文首先介绍了不同的完整性保护方案，数据结构以及他们各自优缺点。然后结合内存完整性保护的需求与场景，指出已有的完整性保护的方案都不能很好适应云场景。本文具体分析了其中的原因，第一：完整性保护的内存
大小受限；第二：无法动态的分配受保护的内存；第三：无法支持离散的内存保护。本文针对已有完整性保护方案中的这三点缺陷，提出了一种新的完整性保护方案：可挂载的完整性保护树（Mountable merkle tree），
并且提出了两个完整性保护树的动态原语，挂载（Mount）与卸载（unMount）。可挂载的完整性保护树能够很好的和兼容已有的完整性保护方案，在不需要更改已有数据结构基础上，增加少量元数据结构以及硬件扩展，就能
解决原有的完整性保护方案的三个主要缺陷。同时，论文中也提出了新的树的组织结构，能够进一步提高树中节点的扇出。在测试方面，我们使用gem5进行模拟，测试结果显示在大多数场景下，可挂载的完整性保护树能够减少
2~10倍的性能开销，为云场景下的内存完整性保护提供了可能。

总体来说，本文的贡献如下：
\begin{itemize}
    \item 分析了已有完整性保护方案的优缺点，以及在云场景下的不足与缺陷
    \item 提出了可挂载的完整性保护树，能够支持TB级别的内存以及内存的动态保护
    \item 在gem5模拟器上进行模拟，得到了2-10倍的性能提升。
\end{itemize}

\subsection{论文组织结构}
本论文得组织结构如下：

第一章介绍现阶段相关的研究工作，对各种不同得完整性保护方案做了系统得介绍以及对比。


% \subsection{三级标题}

% \subsubsection{四级标题}

% Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
% incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis
% nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
% Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu
% fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
% culpa qui officia deserunt mollit anim id est laborum.
