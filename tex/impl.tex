\chapter{实现与环境}

\section{实现平台与环境}
我们在\emph{gem5}模拟器上实现了MMT的原型，\emph{gem5}是一个多指令集的全系统模拟器，它可以模拟不同的指令集的（X86, ARM, RISCV， MIPS, SPARC等），不同的CPU模型：单周期，多周期，顺序执行，乱序执行，多发射等，不同的内存层次架构：
无缓存，L1缓存，L2缓存，L2缓存，以及指定每一级缓存的大小，集合，几路缓存等配置参数。同时gem5还对内存做了全模拟，实现了经典的内存模型以及ruby的内存模型。在模拟性能方面，gem5可以使用精确时间的模拟timing，原子的访问模拟atomic，以及性能的访问模式functional，
\emph{gem5}为全系统模拟提供了诸多搭配的选择，同时也提供了较为精确的模拟性能。相较于其他的相关工作使用的的trace模拟器（USIMM），只能够根据内存的访问trace文件，来进行模拟执行，这样的的模拟的精确性将不如全系统模拟。同时全系统模拟可能准确的执行程序并且
给出相应的计算结果，而不仅仅只是对性能的模拟。我们可以在\emph{gem5}上运行的完整的linux系统，或者未经过修改的原程序。
\begin{table}[htp]
    \centering
    \footnotesize
    \caption{\textbf{gem5中参数配置.}}
    \label{t:gem5-config}
    %\setlength{\belowcaptionskip}{0pt}
    %\begin{tabular}{@{}lll@{}}
    %\begin{tabular}{p{2.25cm}p{1.875cm}p{1.875cm}}
    \begin{tabular}{p{3.25cm}<{\centering} p{3.25cm}<{\centering} }
    %\begin{tabular}{@{}lrrrr@{}}
    \toprule
    \multicolumn{2}{c}{\textbf{处理器}} \\ \hline
    指令集              & RISCV    \\
    核数    &   4核 \\
    频率    &   1GZ \\
    L1d 缓存    &   两路，64K   \\
    L1i 缓存    &   两路，32K  \\
    L2 缓存    &   八路，2M  \\
    L3 缓存    &   十六路，16M  \\ \hline
    \multicolumn{2}{c}{\textbf{内存}} \\ \hline
    内存型号与频率    &   lddr3，800mHz \\
    读队列    &   32 \\
    写队列    &   64 \\
    行缓存    &   1K \\
    内存核心数    &   8 \\
    单通道rank数    &   2 \\
    单通道bank数    &   8\\ \hline
    \multicolumn{2}{c}{\textbf{内存时序参数}} \\ \hline
    Tck    &   1.25ns \\
    Tbust    &   5ns \\
    Trcd    &   13,75ns \\
    Tcl   &   13,75ns \\
    Tras    &   35ns \\
    Tcs   &   2.5ns \\
    \bottomrule
    \end{tabular} \\[-5pt]
\end{table}

如表格 ~\ref{t:gem5-config}所示，我们列举gem5配置的处理器，内存以及内存时序参数等。我们选择了指令集为RISCV的处理器，因为RISCV为开源指令集项目，可以方便做指令的修改以及后续的开发。同时市面上也存在诸多RISCV架构的处理和FPGA，能较为方便的从
模拟器中移植到真实的硬件中。我们采用了四核顺序处理的CPU核心，采用了三级缓存结构，其中L3缓存是共享的缓存。在内存控制器方面，内存控制器中的读队列和写队列分别为32和64。我们模拟了lddr3的内存，800mHz的频率，能够适应绝大多数的应用场景。其中单内存条（单通道）
上有两个rank，每个rank上拥有8个内存核心。其余的内存中刷新频率(Tck)，行地址到列地址延迟(Tras)等相关信息可以具体参考表 ~\ref{t:gem5-config}

\begin{table}[htp]
    \centering
    \footnotesize
    \caption{\textbf{MMT中参数配置.}}
    \label{t:gem5-config}
    %\setlength{\belowcaptionskip}{0pt}
    %\begin{tabular}{@{}lll@{}}
    %\begin{tabular}{p{2.25cm}p{1.875cm}p{1.875cm}}
    \begin{tabular}{p{3.25cm}<{\centering} p{3.25cm}<{\centering} }
    %\begin{tabular}{@{}lrrrr@{}}
    \toprule
    \multicolumn{2}{c}{\textbf{MMT配置}} \\ \hline
    子树层数              & 三层   \\
    子树保护内存              & 4M   \\
    根数层数              & 三层   \\
    子树保护内存              & 2M   \\
    MMT元数据区域              & $\approx$2M   \\
    SoC保护内存大小              & 128M   \\
    最大保护内存大小              &  512G   \\
    Mount Table              & 16K   \\
    Secure Bitmap   & 512B \\
    \bottomrule
    \end{tabular} \\[-5pt]
\end{table}

\section{gem5模拟器}
我们在了gem5中的$dram_ctrl$，实现了MMT的原型，为了能够更精确的模拟内存访问的时间，我们选择了Timing模式，Timing模式能够实现原子的内存访问请求，从而更加的精确的计算CPU到内存的延时。gem5是事件驱动的模拟，通过调度器合理的触发事件队列中待完成的事件。
事件包括：Cache想内存控制器发送一个内存访问的数据包，内存进行预充电，将写入内存的数据加入到内存控制器中的写缓存中等等。同时，gem5中不同硬件部件之间的通信时通过包的机制进行的，每一个能够接受消息的部件都会预留四个接口，在Timing模式下为：$recvTimingReq()$，$sendTimingReq()$，$recvTimingResp()$，$sendTimingResp()$，例如cpu中向cache中读取数据，cpu会生成一个包含cache地址，访问权限以及预留
数据的空间等其他包元数据，然后将这个数据包发送给cache单元。在cache单元中$recvTimingReq()$和cpu中的$sendTimingReq$通过管道的机制连接在一起，所以从cpu中的消息可以传到cache中。值得注意的时，cpu中发送消息包会触发一个事件，该事件会加入掉调度的队列中，并且在它该触发的时候执行。例如cpu访问cache需要几个cycles的时间，那么cpu中发送的数据包给cache这个事件就会在对应的cycle数之后才会被调度到。同样道理如果发生
cache miss 数据要从内存中获取时候，cache会生成了一个内存访问的数据包，该数据的包获取数据的大小和一个内存块或缓存行的大小相同，然后将cache向内存控制器发送请求包的事件加入调度队列中，该事件会在一定的延时后触发（模拟cache到内存控制器的延时），当内存控制器获取
数据之后，会填充在请求包的数据区间，然后将包返回给cache，该过程也会产生一个事件，并且在特定的时间点触发。cache即获得了内存中的数据，然后更新cache缓存行中的数据，然后将结果返回给cpu。这就是在gem5中运用包机制以及事件驱动完成对全系统的模拟。

另外gem5对硬件的模拟非常的精准与细致。在cpu上可以模拟不同指令集的cpu核心，在同一个指令集中，也有多种模式可以选择：单周期，多周期，乱序，Timing，atomic等等。在cache方面，可以模拟L1,L2,L3缓存，同时缓存中的集合数以及路数都可以配置，在L1缓存中还区分数据块和代码块，L3cache实现了cache一致性的协议。在内存部分，可以实现丰富的内存模拟，
包括内存的频率（1600、2400）；不同的内存种类（lddr4、lddr4、hmc），不同的内存核心数量，rank和bank的数量，输出引脚的数量等等。除了能够模拟多种内存的模型，还能够精确设置内存性能至关重要的时序参数，例如：Tck、Tras等等。表格 ~\ref{t:gem5-config}中列举了我们模拟中采用的硬件，同时在测试的时候，我们也尝试使用不同的硬件组合，来测试程序运行是的性能。

\section{内存控制器}
内存控制处在SoC上，连接着总线。一个内存控制器控制着一个DIMM，能够触发对内存条的读写指令；当同时存在多个DIMM并插有多个内存条时，就需要有SoC中有多个与之对应的内存控制器。