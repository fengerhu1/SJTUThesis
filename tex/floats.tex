% !TeX root = ../thesis.tex

\chapter{相关技术背景}

\section{Merkle hash tree及其密码学基础}
Merkle hash tree \cite{merkle1987digital}算法首先是由Ralph C. Merkle于1987年在“A DIGITAL SIGNATURE BASED ON A CONVENTIONAL E;UCRYITION FUNCTION”提出，在该论文中首次提出了仅仅依赖于传统加密方法的
数字签名系统，而实现该系统的核心就是Merkle hash tree和Lamport算法。Merkle hash tree算法能够快速查询并且检查签名值是否正确，并且仅仅只需要使用少量的内存（与总内存呈对数相关）。签名的大小往往在
几百个byte到几千byte之间，而生成签名则需要经过多次的底层哈希计算。通过采用了Merkle hash tree算法起先广泛的使用在签名系统中，以保证签名数据的完整性，之后逐渐在网络和文件系统中得到了广泛的应用。近年来，随着
计算机可信执行环境的演进和非易事性内存的商用化，以merkle hash tree为原型的完整性保护算法在在保护运行时内存完整性上起到了关键的作用。

\subsection{单向散列函数与一次性签名}
\subsubsection{单向散列函数}
单向函数是正向计算非常简单，但是逆向计算非常困难的函数，例如给定一个函数F，给定一个输入x，计算 y=F(x)， 非常容易，但是确定x的值使得F(X)=y非常困难。单词散列函数是基于传统的密码学加密函数观察所得：即
给出明文和密文，想要推导出对应的私钥是非常困难的。如果我们定义一个传统的加密函数S(秘钥，明文) = 密文，那么我们可以类比定义一个单向函数F(x) = y，它等价与S(x,0) = y, 其中我们对一个常量用秘钥x进行加密，
得到了密文就是单向函数的输出。如果给出y推导出x那么就等价于我们知道明文是0密文是y就能够推导出秘钥是x，显然这和传统的加密函数的观察结果不符。

单向散列函数，是单向函数中的一种，它能够接受任意长的输入（几千比特），然后产生定长的输出结果（64比特）。在使用单向散列函数时候需要非常小心，因为可能单向散列函数存在“平方根”攻击等安全漏洞，对于一个54
bit的数据，攻击可以通过2的28次操作之后能够生成相同的结果。当然在大多数的场景下，此类攻击的代价会超过攻击对象本身的价值，因此一个良好设计的单向散列函数一般认为是安全的。单向散列函数具有一下几个优点：
\begin{itemize}
    \item 对于任意长度的输入，可以生成固定长度的输出结果
    \item 相较与求幂取模签名计算来说，计算更加快速，并且能够很方便的整合到硬件的设计之中
    \item 输入数据不同，得到的散列值也不同
    \item 具有单向传递性
\end{itemize}

\subsubsection{一次性签名}
一次性签名最早是由Lamport \cite{diffie1976new}在1979年所提出，Lamport经过观察发现，单向散列函数能够提供非常强大的签名方案与系统。下面我们将从签名单比特数据和签名多比特数据分析：

\textbf{单比特签名}：对于A签名一个单比特数据给B，首先A先随机生成两个值x[1], x[2]，然后我们选择一个单向散列函数F，对x[1], x[2]进行计算得到对应的y[1], y[2]。然后我们将y[1]， y[2]作为公钥暴露给B，而x[1], x[2]最为私钥保留在A手中。对于一个单比特数据来说，如果是“0”，那么
我们选择x[1]作为签名个B, 如果是“1”选择x[2]作为签名给B。假设现在单比特消息为“1”，那么B能收到的签名x[2]， B可以通过单向散列F验证F(x[2])，是否等于y[2]，因为在这里F和y[2]都是公开的，所有人都能够去验证这个结果。但是只有A
同时知道x[1], x[2]，根据单向散列的函数的原理，知道y[1], y[2]的B无法推导出x[1],x[2]。然而一次签名并不是完美的，它只能够签名一次，因为一旦签名一次之后，B就能够知道x[1], x[2]中的一个值。B可以通过让A签名不同比特的消息
获取A中所有的私钥，这也是之后提出merkle tree的一个主要出发点。

\textbf{多比特签名}：多比特签名是在但比特签名的基础上演进而来的，对于长度为m的消息来说，分别随机生成x[0:m], x[m, 2m]; 同时选定一个单向散列函数F，分别对x[0:m], x[m, 2m]做计算出y[0:m], y[m:2m]。 跟单比特相似，x作为
A的私钥而Y作为公钥发布给验证签名的B。对于M中的每一个比特，都经过类似单比特的计算，如果是“0”就从x[0:m]中选择，如果是“1”就从x[m:2m]中选择。之后可以得到签名后的数列s[0:m]。将s和M一起传给需要验证的B，B根据
s中每个比特的数值，用公钥y[0:m], y[m:2m]对s[0:m]做验证。因为单向散列函数F的特性，保证了验证者不会通过y推导出私钥x。当然多比特签名仍然存在只能签名一次的问题，并且对于任意消息M，都需要返回一个等长的签名s
给签名的验证着B，并且对于A来说需要生成两倍与验证消息的公私钥对x, y。一种优化的方式是，只生成等长与验证消息的x, y。其中如果消息中的比特是“1”，我们就用x签名，如果是“0”就用0签名。对于这样的优化，我们可以
减少一般的秘钥空间开销。但是显然这样的设计是有问题，例如对于消息“01001110100”，验证者会收到x[2], x[5], x[6], x[7] 和x[9]。但是B不能够保证它收到的消息一定是完整的，恶意的中间攻击者可以将第二个比特从1改成0，同时
传给B x[5], x[6], x[7] 和x[9]，对于B来说他并不能意识到该消息已经被人篡改，签名是无效的。为了解决这个问题，需要在签名中加上该消息中“1”的个数或者其他哈希值，保证消息的完整性，并且将该值和原消息一起被A签名，然后发布给
验证者B。虽然该优化能够减少一半的空间开销，但是对于一个想验证大量消息的B来说，他还需要存储和验证消息相同数量级的公钥y，这对于验证者来说是非常不友好的。

\subsection{Merkle Tree}
为了解决上面所说的验证着需要存储大量的公钥的问题，Ralph C. Merkle提出了一种新颖的数据结构merkle tree，它能够大大的减小验证着需要保存的公钥的大小，从而减少验证者的开销。再论文中，merkle tree是用来进行前面验证，随着merkle tree
的不断发展，也被广泛的应用再完整性保护中。

我们以二叉树为例，在签名系统中Merkle tree中的每个节点保存着三个签名，分别是：左节点认证，右节点认证以及数据的签名。根据二叉树的组织形式，我们很容易根据父节点推到出子节点的标号，例如父节点的编号i，那么他的字节的编号分别是2i，2i+1；同理，如果我们知道子节点的编号
我们很容易知道它的父节点的编号，这一点不论在签名系统还是完整性保护系统中都显得非常的重要。因为验证者可以提前知道每一个节点以及其父子节点的编号，而不需要通过获取父节点之后才能够计算出其子节点的编号。对于一个节点中的，左右子节点认证以及消息签名，分别由三组私钥x，公钥y
完成签名认证。同时我们选择一个合适散列函数，对该节点中的公钥进行哈希计算，得到的哈希值由其对应的父节点进行签名认证。通过这样的机制，可以大大减少验证者需要知道的信息的大小。在merkle tree的验证中，验证者们只需要知道根节点的哈希值，当验证者需要验证第i条消息是否被签名者
签名过，签名者需要讲第i个消息，以及对应的公钥发给验证者。然后签名者通过自己的私钥，对需要签名的消息进行签名，并且把签名后的结果发给验证者。验证者通过公钥验证签名结果是否正确，如果通过验证，验证者将该节点所有的公钥的哈希值以及对应的父节点公钥发给用户，验证者可以通过父节点中的
公钥验证哈希值是否正确。如果当前的节点已经是根节点，因为根节点的哈希值被所有的验证者保存，验证者通过将计算得到的根节点哈希值和自己保存的根节点哈希值做对比，如果两者一致，那么整个签名的过程得到验证；反之，签名验证失败。通过merkle tree的组织形式，验证者所需要知道的共识仅限于根节点的哈希值
，另外在验证过程中，签名者会向验证者发送仅仅对数于总消息数量的信息，用于辅助验证签名的合法性。

merkle tree最初使用在签名的系统中，但是之后被广泛的应用在了完整性保护中，和签名系统中的结构相似，一、需要保护数据的完整性；二、需要保证验证者只需存储少量的信息。在完整性保护架构中，保护的数据被分成不同的数据块，采用merkle tree保护所有数据块的完整性。在数的叶子节点中，存储着所有的数据块的
哈希值，而父节点中存储着所有子节点的哈希和得哈希。数据块得完整性由叶子节点的哈希值保证，所有叶子节点哈希值得完整性由父节点保证，一次类推，我们只要保证根节点得哈希不被篡改，即可以保证数据块中数据得完整性。以merkle tree得形式保证数据得完整性，由一下几点好处：
\begin{itemize}
    \item 需要存储得可信数据很小：根节点哈希，其余节点可以存在不可信的存储中
    \item 可以并发进行数据哈希校验，每个数据块的哈希不依赖其他数据块，可以同时进行
    \item 支持数据更新后，只需要更新对应部分的哈希值即可，不需要对所有的数据进行重计算
    \item 对单个数据块完整性验证的次数和数据块的总数成对数相光
\end{itemize}
除了merkle tree的结构，还存在链表等结构，但是相较于merkle tree而言，无法并发进行完整性保护验证，以及不支持动态更新，在这里就不做更多的阐述。