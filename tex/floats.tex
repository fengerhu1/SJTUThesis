% !TeX root = ../thesis.tex

\chapter{相关技术背景}

\section{Merkle hash tree及其密码学基础}
Merkle hash tree \cite{merkle1987digital}算法首先是由Ralph C. Merkle于1987年在“A DIGITAL SIGNATURE BASED ON A CONVENTIONAL E;UCRYITION FUNCTION ”提出，在该论文中首次提出了仅仅依赖于传统加密方法的
数字签名系统，而实现该系统的核心就是Merkle hash tree和Lamport算法。Merkle hash tree算法能够快速查询并且检查签名值是否正确，并且仅仅只需要使用少量的内存（与总内存呈对数相关）。签名的大小往往在
几百个byte到几千byte之间，而生成签名则需要经过多次的底层哈希计算。通过采用了Merkle hash tree算法起先广泛的使用在签名系统中，以保证签名数据的完整性，之后逐渐在网络和文件系统中得到了广泛的应用。近年来，随着
计算机可信执行环境的演进和非易事性内存的商用化，以merkle hash tree为原型的完整性保护算法在在保护运行时内存完整性上起到了关键的作用。

\subsection{单向散列函数与一次性签名}
\subsubsection{单向散列函数}
单向函数是正向计算非常简单，但是逆向计算非常困难的函数，例如给定一个函数F，给定一个输入x，计算 y=F(x)， 非常容易，但是确定x的值使得F(X)=y非常困难。单词散列函数是基于传统的密码学加密函数观察所得：即
给出明文和密文，想要推导出对应的私钥是非常困难的。如果我们定义一个传统的加密函数S(秘钥，明文) = 密文，那么我们可以类比定义一个单向函数F(x) = y，它等价与S(x,0) = y, 其中我们对一个常量用秘钥x进行加密，
得到了密文就是单向函数的输出。如果给出y推导出x那么就等价于我们知道明文是0密文是y就能够推导出秘钥是x，显然这和传统的加密函数的观察结果不符。

单向散列函数，是单向函数中的一种，它能够接受任意长的输入（几千比特），然后产生定长的输出结果（64比特）。在使用单向散列函数时候需要非常小心，因为可能单向散列函数存在“平方根”攻击等安全漏洞，对于一个54
bit的数据，攻击可以通过2的28次操作之后能够生成相同的结果。当然在大多数的场景下，此类攻击的代价会超过攻击对象本身的价值，因此一个良好设计的单向散列函数一般认为是安全的。单向散列函数具有一下几个优点：
\begin{itemize}
    \item 对于任意长度的输入，可以生成固定长度的输出结果
    \item 相较与求幂取模签名计算来说，计算更加快速，并且能够很方便的整合到硬件的设计之中
    \item 输入数据不同，得到的散列值也不同
    \item 具有单向传递性
\end{itemize}

\subsubsection{一次性签名}
一次性签名最早是由Lamport \cite{diffie1976new}在1979年所提出，Lamport经过观察发现，单向散列函数能够提供非常强大的签名方案与系统。下面我们将从签名单比特数据和签名多比特数据分析：
\textbf{单比特签名}：对于A签名一个单比特数据给B，首先A先随机生成两个值x[1], x[2]，然后我们选择一个单向散列函数F，对x[1], x[2]进行计算得到对应的y[1], y[2]。然后我们将y[1]， y[2]作为公钥暴露给B，而x[1], x[2]最为私钥保留在A手中。对于一个单比特数据来说，如果是“0”，那么
我们选择x[1]作为签名个B, 如果是“1”选择x[2]作为签名给B。假设现在单比特消息为“1”，那么B能收到的签名x[2]， B可以通过单向散列F验证F(x[2])，是否等于y[2]，因为在这里F和y[2]都是公开的，所有人都能够去验证这个结果。但是只有A
同时知道x[1], x[2]，根据单向散列的函数的原理，知道y[1], y[2]的B无法推导出x[1],x[2]。然而一次签名并不是完美的，它只能够签名一次，因为一旦签名一次之后，B就能够知道x[1], x[2]中的一个值。B可以通过让A签名不同比特的消息
获取A中所有的私钥，这也是之后提出merkle tree的一个主要出发点。
\textbf{多比特签名}：多比特签名是在但比特签名的基础上演进而来的，对于长度为m的消息来说，分别随机生成x[0:m], x[m, 2m]; 同时选定一个单向散列函数F，分别对x[0:m], x[m, 2m]做计算出y[0:m], y[m:2m]。 跟单比特相似，x作为
A的私钥而Y作为公钥发布给验证签名的B。对于M中的每一个比特，都经过类似单比特的计算，如果是“0”就从x[0:m]中选择，如果是“1”就从x[m:2m]中选择。之后可以得到签名后的数列s[0:m]。将s和M一起传给需要验证的B，B根据
s中每个比特的数值，用公钥y[0:m], y[m:2m]对s[0:m]做验证。因为单向散列函数F的特性，保证了验证者不会通过y推导出私钥x。当然



\subsection{数据结构}
